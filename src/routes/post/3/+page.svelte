<script>
	import Paragraph from '$lib/components/Paragraph.svelte';
</script>

<h2 class="h2 pb-4">못생김 휴리스틱</h2>

<Paragraph>
	<strong>'개발자라면 누구나 최소 5가지의 언어는 사용할 줄 알아야 한다.'</strong>

	C++ 창시자가 자기 블로그에 올렸던 말이다. 이를 의식했던 건 아니지만 공교롭게도 현재 나는 Rust,
	Python, JS/TS, C, Java까지 딱 5가지의 언어만을 사용하고 있다. 내심 찜찜하기는 한 게, Java와 C로는
	그 어떤 프로젝트도 완수해본 적이 없기 때문이다. (그렇다고 다른 언어로 무언갈 '완수'해본적이 있냐
	묻는다면...)
</Paragraph>
<Paragraph>
	그렇게 5개의 언어를 익히면서, 각각의 장단점이 이제는 조금 더 명료하게 보이게 되었다. 각 언어들은
	서로만의 멘탈 모델을 갖고 있고, 그 멘탈 모델과 거리가 먼 로직을 작성하면 필연적으로 더럽고 못생긴
	코드가 나올 수밖에 없게 된다.
</Paragraph>

<h2 class="h2 pb-4">Rust</h2>
<Paragraph>
	Rust는 아직까진 내가 제일 좋아하는 언어이자, 많이 사랑받는 언어이다. 다만 나는 Rust가 개발자
	커뮤니티가 주목하는 만큼 좋은 언어는 아니라고 생각한다.
</Paragraph>
<Paragraph>
	내가 생각하는 Rust의 멘탈 모델은, 메모리 안정성 같은 구체적인 휴리스틱보다
	<strong>컴파일러가 모든 것을 알게한다</strong>는 것에 있는 것 같다. 메모리 언제 해제할지, 무슨
	타입의 인자를 받을지 등등의 코드 작업에 대한 모든 정보를 런타임 전에 알아낸다. 물론
	<code>dyn</code> 같은 키워드들도 있기야 하지만, 애초에 이걸 사용해 잘 돌아가는 코드를 설계하는 건 거의
	불가능에 가깝다. 아주 딱딱한 타입 시스템 때문인데, 한 번 쓰기 시작하면 모듈 전체가 dyn 키워드를 계속
	쓰게 되는 상황에 이를 수 있다. 결국 이럴 꺼면 그냥 Java를 쓰는 게 낫다.
</Paragraph>

<h2 class="h2 pb-4">Rust 코드가 더러워지는 순간</h2>
<Paragraph>
	Rust로 개발된 소스를 보다 보면, 제네릭이 덕지 덕지 붙어 있는 코드를 볼 수 있게 된다. 다른 평범한
	객체지향적 언어들은 이 제네릭이 쉽게 남용되지 않지만, Rust에서는 trait들이 제네릭을 경유해서
	추상화되기 때문에 이게 결과적으로 덕지덕지 붙어 있는 꼴로 나타날 수밖에 없다. 물론 그렇게 맞는
	말은 아니다. 이쁘기가 어렵다는 게 주요 시사점이다.
</Paragraph>
<Paragraph>
	또 다른 시점도 있는데, 바로 매크로이다. 이건 언어 자체의 문제라기 보다는 아직 매크로 해석을
	지원하는 제대로 된 lsp가 없다는 것 때문이다. 이것도 사실 언어 자체의 문제라고 보는 시각도 있는데,
	그런 lsp가 없는 이유가 borrow checking 때문이다. 이걸 위해서 hir, mir 등의 해석 중간 단계가
	컴파일에 껴있는데, 이거 매크로에 제대로 적용하기가 어려워서인 것으로 알고 있다.
</Paragraph>

<h2 class="h2 pb-4">Java</h2>
<Paragraph>
	사실 이건 자바 만의 문제는 아니고, oop 지원하는 모든 언어들에게서 공통적으로 나타나는 문제점이다.
	바로 상속에 관한 것인데, 나는 super가 있는 코드를 그렇게 읽기가 싫더라. Rust 개발자들의 특징 중
	하나인데, 조금만 명시적이지 않은 코드를 읽으면 두드러기가 난다.
</Paragraph>
<Paragraph>
	아 그리고, 얘네는 타입 추론이란 게 없어서 그냥 항상 타입 다 써야 하는 게 매우 어지럽다.
</Paragraph>
