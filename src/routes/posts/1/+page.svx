# 강한 타입 시스템의 유일한 단점

'타입'이라는 단어의 의미를 정의해보자면, 여러 맥락에서 다른 해석도 충분히 가능하겠으나
개인적으로는 '작업자가 틀리지 않게 하는 모든 수단'이라는 관점으로 바라 보는 것이 꽤 괜찮은
해석이라고 생각한다. 그렇기 때문에 엉성한 캐스팅을 지원하는 Java, C와 같은 언어를 나는
사실상의 static type lang으로 보지 않는다. 억지스러운 예시지만 C에서는 다음과 같이 억지
프로그램을 작성할 수 있다.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    void *data = malloc(64);  // 그냥 큰 메모리 블록 잡고
    *(int *)data = 12345;     // 첫 4바이트는 int
    *(double *)((char *)data + 4) = 3.14159; // 그 다음 8바이트는 double
    *(char **)((char *)data + 12) = "String in a void*?"; // 그리고 문자열 포인터?

    printf("Integer: %d\\n", *(int *)data);
    printf("Double: %f\\n", *(double *)((char *)data + 4));
    printf("String: %s\\n", *(char **)((char *)data + 12));

    // 여기서 해제할 때도 대참사
    free(data);
    return 0;
}
```

Dynamic casting을 모두 잡기 시작하면 한도 끝도 없겠지만, 이런 걸 모두 개선했기에 모던 프로그래밍 언어들이 각광받는 것이다.
개선이라고 보는 것이 맞다고 생각한다. 이러한 단단한 바운더리는 트레이드 오프 없이 항상 좋은 점을 가져다준다. 다만,
사람들이 이런 static typing을 싫어하는 가장 큰 이유는 바로 타입 명시에서 오는 boilerplate가 너무 심하기 때문인데, 나는
Hindley Milner가 있는 이상 이게 static type에서 유래된 게 아니라 너무 단순한 언어 디자인 때문이라고 생각한다.
HM type system도 컴파일 시간 상 트레이드 오프가 있긴 하지만, 16GB 메모리가 초라해질 정도로 기술이 발전한 이상 HM이 그렇게
컴파일을 늦춘다고 생각하진 않는다.


# 그래서 갑자기 타입 얘기를 왜 하냐고?

아 제목을 보면 알겠지만 이 포스트는 Rust AI tool에 대한 이야기이다. 내가 이런 툴들에 익숙하지 않긴 하지만, 다른 언어들을 쓸 때에 비해
Rust AI 서포트가 매우 구리다. 엄청나게 억지스러운 type system 때문이다. 앞서 언급했듯, 이건 borrow check 시스템을 포함하는 맥락에서의
type system을 말하는 것이다. 이것도 '틀리지 않게 돕는' 툴이니까.

아무튼 여기서 비대해진 타입 시스템의 가장 큰 tradeoff가 발생하는데, 바로 AI의 제한적인 컴파일러 접근성 때문에 인과 추론에 꽤 애를 먹는다는 것이다.
아직 제대로 된 Cargo mcp server가 있지도 않고, 또 Rust가 아주 빠르게 성장하는 탓에 제대로 학습 정보들이 업데이트되지 않는 점도 크다.

이건 타입 문제는 아니지만, 아주 유용하지만 디버깅하긴 어려운 macro의 존재도 한몫한다. Rust가 엔터프라이즈 레벨이 아니면 사용하기 쉽지 않은 이유이다.


# AI tools

나는 현재 zed editor를 사용하고 있다. 아직 뭐 부족한 점이 한 둘이 아니지만, 속도 면에서 꽤 봐줄만한 프로그램인 것 같다.
이후에 ai 툴들을 합쳐 보고, 결과가 있으면 이 포스트에 기록해보도록 하겠다.
